package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/url"
	"sync"

	"github.com/valyala/fasthttp"
)

type Data struct {
	Domain string `json:"domain"`
	Source string `json:"source"`
}

type Datas struct {
	Domains []Data `json:"domains"`
}

type Response struct {
	StatusCode          int
	IsResponseContentOk bool
	Linkgraph           Linkgraph
	Data                Data
	Backlinktool        Backlinktool
}
type Linkgraph struct {
	RefdomainCount int `json:"refdomain_count"`
	BacklinksCount int `json:"backlinks_count"`
	DomainRating   int `json:"domain_rating"`
}

type Rankwatch struct {
	Error    int         `json:"error"`
	ErrorMsg string      `json:"error_msg"`
	Backlink string      `json:"backlink"`
	Response interface{} `json:"response"`
}

type Backlinktool struct {
	Command  string        `json:"command"`
	Old      string        `json:"old,omitempty"`
	New      string        `json:"new,omitempty"`
	Selector interface{}   `json:"selector,omitempty"`
	Method   string        `json:"method,omitempty"`
	Args     []interface{} `json:"args,omitempty"`
}

var Client *fasthttp.Client

func Initialize() {
	Client = &fasthttp.Client{
		MaxConnsPerHost: 20000,
		TLSConfig:       &tls.Config{InsecureSkipVerify: true},
	}
}

func getFromLinkgraph(r *Response, wg *sync.WaitGroup) {
	defer wg.Done()

	req := fasthttp.AcquireRequest()
	res := fasthttp.AcquireResponse()
	defer fasthttp.ReleaseRequest(req)

	req.Header.SetMethod("GET")
	//	req.Header.SetContentType("application/json")
	req.SetRequestURI(fmt.Sprint("https://public.linkgraph.io/api/signup-analytic-flow/domain-analyzer/?domain=" + r.Data.Domain))
	req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36")

	err := Client.Do(req, res)
	if err != nil {
		log.Println("Request Domain:", r.Data.Domain, " Error: ", err)
		return
	}

	r.StatusCode = res.StatusCode()
	if r.StatusCode == 200 {
		err = json.Unmarshal(res.Body(), &r.Linkgraph)
		if err != nil {
			log.Println("Unmarshal Domain: ", r.Data.Domain, " Error: ", err)
			return
		}
		fmt.Println("Linkgraph | Domain:", r.Data.Domain)
		fmt.Println("Backlink Count:", r.Linkgraph.BacklinksCount)
		fmt.Println("Ref Domain Count:", r.Linkgraph.RefdomainCount)
		fmt.Println("Domain Rating:", r.Linkgraph.DomainRating)
	}

	if r.StatusCode == 406 {
		fmt.Println(r.Data.Domain, "406 Not Acceptable error")
	}
	// if r.Linkgraph.Competitors.SeoCompetitors != nil {
	// 	r.IsResponseContentOk = true
	// }

	return
}

func getFromBacklinktool(r *Response, wg *sync.WaitGroup) {
	defer wg.Done()

	values := url.Values{}
	values.Set("domain", r.Data.Domain)
	values.Set("analysis", "true")
	values.Set("form_build_id", "form-uKkFjUrWHrWz8DtBY0eUrqML5zgONiy1pcjGqJKAHoE")
	values.Set("form_id", "backlinkcheck_form")

	req := fasthttp.AcquireRequest()
	res := fasthttp.AcquireResponse()
	defer fasthttp.ReleaseRequest(req)
	//defer fasthttp.ReleaseResponse(res)

	req.Header.SetMethod("POST")
	req.Header.SetContentType("application/x-www-form-urlencoded")
	req.SetRequestURI(fmt.Sprint("https://www.backlink-tool.org/en/?analysis=true&ajax_form=1&_wrapper_format=drupal_ajax"))
	req.SetBodyString(values.Encode())

	err := Client.Do(req, res)
	if err != nil {
		log.Println("Request Domain:", r.Data.Domain, " Error: ", err)
		return
	}

	//var data []AutoGenerated
	r.StatusCode = res.StatusCode()
	if r.StatusCode == 200 {
		err = json.Unmarshal(res.Body(), &r.Backlinktool.Args)
		if err != nil {
			log.Println("Unmarshal Domain: ", r.Data.Domain, " Error: ", err)
			return
		}

		log.Println(r.Backlinktool.Args[5])
	}

	return
}
func testApiNinjas(domains []Data) {
	var responses []*Response
	var wg sync.WaitGroup

	for _, domain := range domains[:10] {
		r := Response{}
		r.Data = domain

		wg.Add(1)
		go getFromBacklinktool(&r, &wg)

		responses = append(responses, &r)

		//log.Println(fmt.Sprintf("%d/%d - %s", len(responses), len(domains), domain.Domain))

	}

	wg.Wait()

	var count200, count400, count406, count500 int

	for _, r := range responses {
		if r.StatusCode == 200 {
			count200++
		} else if r.StatusCode == 400 {
			count400++
		} else if r.StatusCode == 406 {
			count406++
		} else if r.StatusCode == 500 {
			count500++
		}
	}
	log.Println(fmt.Sprintf("200: %d, 400: %d, 406: %d 500: %d, Total: %d", count200, count400, count406, count500, len(responses)))

}

func main() {
	Initialize()
	file, err := ioutil.ReadFile("./domain.json")
	if err != nil {
		log.Println("HATA VAAAAAR!", err)
		return
	}

	data := Datas{}
	err = json.Unmarshal(file, &data)
	if err != nil {
		log.Println("HATA VAAAAAR!!", err)
		return
	}

	// for _, row := range data.Domains {
	// 	log.Println(row)
	// }
	testApiNinjas(data.Domains)
}
